!+ Compute Lagrangian cubic derivative estimates
!+ $Id: cubydr.f90,v 1.5 1999/08/27 17:00:19 m214030 Exp $

SUBROUTINE cubydr(pf,fint,wdy,jdp,fyb,fyt)

  ! Description:
  !
  ! Compute Lagrangian cubic derivative estimates.
  !
  ! Method:
  !
  ! Compute Lagrangian cubic derivative estimates at both ends of the
  ! intervals in the y coordinate (unequally spaced) containing the
  ! departure points for the latitude slice being forecasted.
  !
  ! Authors:
  !
  ! Original version:  J. Olson
  ! Standardized:      J. Rosinski, June 1992
  ! Reviewed:          D. Williamson, P. Rasch, August 1992
  ! Modified:          U. Schlese,  DKRZ - Hamburg,  May 1994
  ! f90 version:       L. Kornblueh, U. Schulzweida, May 1998
  ! 
  ! for more details see file AUTHORS
  !

  USE mo_grid, ONLY: pgls, platd
  USE mo_slt,  ONLY: ppdy

  IMPLICIT NONE

  !  Scalar arguments with intent(In):
  INTEGER, INTENT (IN) :: pf

  !  Array arguments with intent(In):
  REAL, INTENT (IN) :: fint(pgls,ppdy,pf), wdy(4,2,platd)
  INTEGER, INTENT (IN) :: jdp(pgls)

  !  Array arguments with intent(Out):
  REAL, INTENT (OUT) :: fyb(pgls,pf), fyt(pgls,pf)
 
  ! pf      Number of fields being interpolated.
  ! fint    (fint(i,k,j,m),j=1,ppdy) contains the x interpolants at each
  !         latitude needed for the y derivative estimates at the
  !         endpoints of the interval that contains the departure point
  !         for grid point (i,k).  The last index of fint allows for
  !         interpolation of multiple fields. fint is generated by a
  !         call to herxin.
  ! wdy     Weights for Lagrange cubic derivative estimates on the
  !         unequally spaced latitude grid. If grid interval j (in
  !         extended array) is surrounded by a 4 point stencil, then
  !         the derivative at the "bottom" of the interval uses the
  !         weights wdy(1,1,j),wdy(2,1,j), wdy(3,1,j), and wdy(4,1,j).
  !         The derivative at the "top" of the interval uses wdy(1,2,j),
  !         wdy(2,2,j), wdy(3,2,j), and wdy(4,2,j).
  ! jdp     jdp(i,k) is the index of the y-interval that contains the
  !         departure point corresponding to global grid point (i,k) in
  !         the latitude slice being forecasted.
  !         Suppose yb contains the y-coordinates of the extended array
  !         and ydp(i,k) is the y-coordinate of the departure point
  !         corresponding to grid point (i,k).  Then,
  !         yb(jdp(i,k)) .le. ydp(i,k) .lt. yb(jdp(i,k)+1) .
  ! fyb     fyb(i,k,.) is the derivative at the bottom of the y interval
  !         that contains the departure point of global grid point (i,k).
  ! fyt     fyt(i,k,.) is the derivative at the top of the y interval
  !         that contains the departure point of global grid point (i,k).

  !  Local scalars: 
  INTEGER :: i, m

  !  Local arrays: 
  REAL :: wdytem(pgls,4,2)  ! Work array to gather weights


  !  Executable statements 

  ! Load temp arrays with weights for Lagrangian cubic derivative
  ! estimates on unequally spaced grid.

  DO i = 1, pgls
    wdytem(i,1,1) = wdy(1,1,jdp(i))
    wdytem(i,2,1) = wdy(2,1,jdp(i))
    wdytem(i,3,1) = wdy(3,1,jdp(i))
    wdytem(i,4,1) = wdy(4,1,jdp(i))
    wdytem(i,1,2) = wdy(1,2,jdp(i))
    wdytem(i,2,2) = wdy(2,2,jdp(i))
    wdytem(i,3,2) = wdy(3,2,jdp(i))
    wdytem(i,4,2) = wdy(4,2,jdp(i))
  END DO

  ! Loop over fields.

  DO m = 1, pf
    DO i = 1, pgls
      fyb(i,m) = wdytem(i,1,1)*fint(i,1,m) + wdytem(i,2,1)*fint(i,2,m) + &
&          wdytem(i,3,1)*fint(i,3,m) + wdytem(i,4,1)*fint(i,4,m)

      fyt(i,m) = wdytem(i,1,2)*fint(i,1,m) + wdytem(i,2,2)*fint(i,2,m) + &
&          wdytem(i,3,2)*fint(i,3,m) + wdytem(i,4,2)*fint(i,4,m)
    END DO
  END DO

  RETURN
END SUBROUTINE cubydr
